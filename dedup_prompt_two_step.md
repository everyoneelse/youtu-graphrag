# 两步式去重Prompt设计

## 设计理念

将去重任务分解为两个独立的步骤：

1. **步骤1：等价性分组** - 判断哪些tail应该合并（去重逻辑）
2. **步骤2：代表选择** - 从每个等价组中选择最优代表（选择逻辑）

## 优势

✅ **关注点分离** - 每个步骤只做一件事，逻辑更清晰  
✅ **易于理解** - LLM可以分步骤思考，不会混淆两个任务  
✅ **易于调试** - 可以分别检查分组正确性和代表选择正确性  
✅ **易于优化** - 可以独立调整两个步骤的规则  

---

## Prompt结构

```
================================================================================
任务说明
================================================================================
这是一个两步骤的过程：
步骤1：判断哪些tail是等价的，进行分组
步骤2：对于每个等价组，选择最优的代表

================================================================================
步骤1：等价性分组（判断哪些tail应该合并）
================================================================================

[关系类型判断]
- 别名关系 → 不要去重
- 事实关系 → 应该去重

[等价性判断原则]
- 指称测试
- 替换测试  
- 等价类检查

[禁止的合并理由]
- 部分-整体关系
- 并列列举
- 语义相似
- ...

================================================================================
步骤2：代表选择（为每个等价组选择最优表达）
================================================================================

[选择原则（按优先级）]
1. 信息完整性
2. 自解释性
3. 规范性
4. 无歧义性
5. 受众适配

[禁止的选择标准]
- ✗ 形式特征（长度、简洁性）
- ✗ 位置特征（索引、顺序）
- ✗ 频率特征（出现次数）
- ✗ 主观特征（熟悉度）

================================================================================
输出要求
================================================================================
1. 每个输入索引恰好出现在一个组中
2. 每个组代表一个实体及其各种表达
3. 提供理由：
   a) 为什么这些tail是等价的（步骤1推理）
   b) 为什么选择这个代表（步骤2推理）
```

---

## 完整Prompt示例（中文版）

### 步骤1：等价性分组

```
================================================================================
步骤1：等价性分组（判断哪些tail应该合并）
================================================================================

关系类型感知：

1. 如果关系是【表达收集型】→ 不要去重
   • 别名/异名关系：'别名', 'has_alias', 'also_known_as'
   • 同义词关系：'同义词', 'synonym'
   • 翻译关系：'翻译', 'translation'
   
   示例：(MRI, 别名, "MRI") + (MRI, 别名, "磁共振成像")
   → 不合并！保留两者，因为关系目的是收集多个名称

2. 如果关系是【实体指向型】→ 应该去重
   • 位置关系：'位于', 'located_in'
   • 因果关系：'导致', 'causes', '治疗'
   • 属性关系：'has_property', '属性值'
   
   示例：(医院, 位于, "北京市") + (医院, 位于, "北京")
   → 应合并！它们指向同一地点

等价性判断原则（ALL must hold）：

1. 指称测试：两个tail是否指向完全相同的实体？
   • 相同实体，不同名称 → 合并
   • 不同实体 → 保持分离

2. 替换测试：能否在所有上下文中互换而不改变含义？
   • 替换改变含义 → 保持分离
   • 替换保留含义 → 合并

3. 等价类检查：合并后，所有成员必须指向同一个实体
   • 不要创建包含多个不同实体的组

禁止的合并理由：

✗ 部分-整体关系："X和Y是Z的组成部分" → 不同部分 ≠ 同一实体
  • 错误：合并"颈椎"+"胸椎"+"腰椎"
  • 正确：保持分离，它们是脊柱的不同部分

✗ 并列列举："X、Y、Z被一起列举" → 列举 ≠ 等价

✗ 语义相似："X和Y相似/相关" → 相似 ≠ 同一

✗ 相同类别："都是类型T" → 类别成员 ≠ 实体同一

✗ 集合成员："X, Y ∈ 集合S" → 在同一集合 ≠ 同一元素

✗ 共现："X和Y一起出现" → 上下文接近 ≠ 等价

✗ 功能关系："X导致/影响Y" → 关系 ≠ 同一
```

### 步骤2：代表选择

```
================================================================================
步骤2：代表选择（为每个等价组选择最优表达）
================================================================================

对于步骤1中识别的每个等价组，选择ONE成员作为代表。

选择原则（按优先级顺序应用）：

1. 信息完整性：优先选择传达更多信息的表达
   • 完整形式 > 缩写
     示例：'磁共振成像' > 'MRI'
   • 完整名称 > 部分名称
     示例：'北京市' > '北京'

2. 自解释性：优先选择无需领域知识即可理解的表达
   • 描述性术语 > 技术代码
     示例：'高血压' > 'I10'
   • 通用名称 > 化学式（通用语境）
     示例：'水' > 'H₂O'

3. 规范性：优先选择该领域的标准/官方形式
   • 官方名称 > 非正式名称
   • 现行名称 > 已废弃名称

4. 无歧义性：优先选择歧义较少的表达
   • 特定术语 > 通用术语（专业语境）
     示例：'乙酰水杨酸' > '阿司匹林'（医学语境）

5. 受众适配：当原则冲突时，根据知识图谱的目标受众决定

禁止的选择标准：

✗ 形式特征：长度、简洁性、紧凑性
  → 信息完整性 > 简洁性
  
✗ 位置特征：字母顺序、索引位置、出现顺序
  → 任意排序无关紧要
  
✗ 频率特征：出现频率、哪个先被提及
  → 描述性 > 频率
  
✗ 主观特征：熟悉度、个人偏好
  → 使用客观原则

核心原则：
代表选择必须基于语义和信息价值，而不是基于形式、位置或频率。
选择信息量最大、最具自解释性的表达，无论其长度或出现频率。
```

---

## 输出格式

```json
{
  "groups": [
    {
      "members": [0, 2],
      "representative": 2,
      "rationale": "步骤1：'SE序列'和'自旋回波序列'指向同一MRI脉冲序列，满足指称测试和替换测试。步骤2：选择'自旋回波序列'作为代表，因为它是完整形式，具有更好的自解释性（信息完整性原则）。"
    },
    {
      "members": [1],
      "representative": 1,
      "rationale": "单独的实体，无需合并。"
    }
  ]
}
```

---

## 示例应用

### 案例1：别名关系（步骤1判断：不合并）

**输入：**
```
关系：别名
候选tail：
0. "MRI"
1. "磁共振成像"
2. "核磁共振"
```

**步骤1判断：**
- 关系类型：表达收集型（别名关系）
- 判断：不要去重，保留所有tail
- 结果：3个独立的组

**输出：**
```json
{
  "groups": [
    {"members": [0], "representative": 0, "rationale": "别名关系不去重，保留'MRI'作为独立别名"},
    {"members": [1], "representative": 1, "rationale": "别名关系不去重，保留'磁共振成像'作为独立别名"},
    {"members": [2], "representative": 2, "rationale": "别名关系不去重，保留'核磁共振'作为独立别名"}
  ]
}
```

---

### 案例2：位置关系（步骤1判断：合并 + 步骤2选择）

**输入：**
```
关系：位于
候选tail：
0. "北京"
1. "北京市"
```

**步骤1判断：**
- 关系类型：实体指向型（位置关系）
- 指称测试：都指向同一城市 ✓
- 替换测试：可以互换 ✓
- 判断：应该合并

**步骤2选择：**
- 候选："北京" vs "北京市"
- 应用原则1（信息完整性）："北京市"是完整的官方行政名称
- 应用原则3（规范性）："北京市"是官方形式
- 选择："北京市"

**输出：**
```json
{
  "groups": [
    {
      "members": [0, 1],
      "representative": 1,
      "rationale": "步骤1：'北京'和'北京市'指向同一城市，满足指称测试和替换测试。步骤2：选择'北京市'作为代表，因为它是完整的官方行政名称（信息完整性和规范性原则）。"
    }
  ]
}
```

---

### 案例3：部位关系（步骤1判断：不合并）

**输入：**
```
关系：常见于
候选tail：
0. "颈椎"
1. "胸椎"
2. "腰椎"
```

**步骤1判断：**
- 关系类型：实体指向型（事实关系）
- 指称测试：三者指向不同的解剖部位 ✗
- 替换测试：不能互换（"颈椎、胸椎、腰椎"替换为"颈椎、颈椎、颈椎"会改变含义）✗
- 禁止理由检查：触发"部分-整体关系"禁止 ✗
- 判断：不应该合并

**输出：**
```json
{
  "groups": [
    {"members": [0], "representative": 0, "rationale": "步骤1：'颈椎'是独立的解剖部位，与其他部位是脊柱的不同部分（部分-整体关系），不应合并。"},
    {"members": [1], "representative": 1, "rationale": "步骤1：'胸椎'是独立的解剖部位，与其他部位是脊柱的不同部分（部分-整体关系），不应合并。"},
    {"members": [2], "representative": 2, "rationale": "步骤1：'腰椎'是独立的解剖部位，与其他部位是脊柱的不同部分（部分-整体关系），不应合并。"}
  ]
}
```

---

### 案例4：序列类型（步骤1判断：合并 + 步骤2选择）

**输入：**
```
关系：使用序列
候选tail：
0. "SE序列"
1. "自旋回波序列"
```

**步骤1判断：**
- 关系类型：实体指向型
- 指称测试：都指向同一MRI脉冲序列 ✓
- 替换测试：可以互换 ✓
- 判断：应该合并

**步骤2选择：**
- 候选："SE序列" vs "自旋回波序列"
- 应用原则1（信息完整性）："自旋回波序列"是完整形式
- 应用原则2（自解释性）："自旋回波序列"无需领域知识即可理解
- 禁止标准检查：不能因为"SE序列"更短就选它 ✗
- 选择："自旋回波序列"

**输出：**
```json
{
  "groups": [
    {
      "members": [0, 1],
      "representative": 1,
      "rationale": "步骤1：'SE序列'和'自旋回波序列'指向同一MRI脉冲序列，满足指称测试和替换测试。步骤2：选择'自旋回波序列'作为代表，因为它是完整形式，具有更好的自解释性，无需领域知识即可理解（信息完整性和自解释性原则）。"
    }
  ]
}
```

---

## 决策流程图

```
输入：Head, Relation, Tail候选集

↓

[步骤1：等价性分组]
├─ 关系类型判断
│  ├─ 表达收集型（别名/同义词/翻译）→ 不去重 → 输出：每个tail独立成组
│  └─ 实体指向型（事实关系）→ 继续
│
├─ 对每对tail(Ti, Tj)：
│  ├─ 指称测试：指向同一实体？
│  │  ├─ 否 → 不合并
│  │  └─ 是 → 继续
│  │
│  ├─ 替换测试：可以互换？
│  │  ├─ 否 → 不合并
│  │  └─ 是 → 继续
│  │
│  └─ 禁止理由检查
│     ├─ 触发（部分-整体/并列/...）→ 不合并
│     └─ 未触发 → 合并
│
└─ 输出：等价组列表

↓

[步骤2：代表选择]
├─ 对每个等价组：
│  ├─ 应用选择原则（优先级顺序）：
│  │  1. 信息完整性
│  │  2. 自解释性
│  │  3. 规范性
│  │  4. 无歧义性
│  │  5. 受众适配
│  │
│  └─ 避免禁止标准：
│     ├─ ✗ 形式特征（长度）
│     ├─ ✗ 位置特征（顺序）
│     ├─ ✗ 频率特征（出现次数）
│     └─ ✗ 主观特征（熟悉度）
│
└─ 输出：每组的representative

↓

最终输出：groups列表（包含members, representative, rationale）
```

---

## 关键优势总结

### 1. 清晰的关注点分离

| 方面 | 单步混合 | 两步分离 |
|------|---------|---------|
| **认知负担** | 同时考虑"是否合并"和"选哪个" | 先考虑"是否合并"，再考虑"选哪个" |
| **逻辑清晰度** | 两个任务交织，容易混淆 | 每步只做一件事，逻辑清晰 |
| **可调试性** | 难以定位问题（分组错误？选择错误？） | 易于定位（步骤1错误 vs 步骤2错误） |

### 2. 更好的prompt组织

```
单步混合：
├─ 合并条件
├─ 禁止合并理由
├─ 选择原则  ← 混在一起，容易误解
└─ 禁止选择标准

两步分离：
步骤1：
├─ 合并条件
└─ 禁止合并理由
步骤2：
├─ 选择原则
└─ 禁止选择标准  ← 清晰分离
```

### 3. 独立的评估和优化

- **步骤1评估**：分组准确率（precision/recall）
- **步骤2评估**：代表选择质量（是否符合原则）
- **独立优化**：可以分别调整两个步骤而不互相干扰

### 4. 更好的可解释性

理由说明明确标注每一步的推理：
```
"步骤1：为什么合并（或不合并）
 步骤2：为什么选择这个代表"
```

---

这种两步分离的设计更符合软件工程的"单一职责原则"，使得去重系统更清晰、更易维护、更易调试。
