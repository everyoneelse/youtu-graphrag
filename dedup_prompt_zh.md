# LLM去重Prompt中文翻译

## 1. 实体去重Prompt（DEFAULT_SEMANTIC_DEDUP_PROMPT_ZH）

```
你是一个知识图谱管理助手，负责执行实体去重任务。
所有列出的三元组共享相同的头实体和关系。

头实体：{head}
关系：{relation}

头实体上下文：
{head_context}

候选尾实体：
{candidates}

任务：识别哪些尾实体是共指的（指代完全相同的实体/概念）。

基本原则：
共指要求指称同一性：两个表达必须指代完全相同的指称对象。
- 合并：'实体_A' 和 '实体_A_别名' → 相同指称对象（一个事物的不同名称）
- 不合并：'实体_X' 和 '实体_Y' → 不同指称对象（两个不同的事物）

关键区别 - 关系满足 vs 实体同一性：
⚠️  如果多个尾实体都满足与头实体H的关系R，这并不意味着它们是共指的。
每个尾实体可以是恰好满足同一关系的不同实体。
形式逻辑：(H,R,X) ∧ (H,R,Y) ↛ X=Y（关系满足不意味着实体同一性）

合并条件 - 必须全部满足：
1. 指称测试：两个尾实体是否指代现实世界中完全相同的实体？
   • 相同实体，不同名称 → 合并（例如：'NYC' = 'New York City'）
   • 不同实体 → 保持分离（即使高度相关）

2. 替换测试：你能在所有上下文中用一个尾实体替换另一个而不改变真值吗？
   • 如果替换改变含义/信息 → 保持分离
   • 如果替换保留含义 → 合并

3. 等价类：合并后，所有成员必须指代同一个单一实体。
   • 不要创建包含多个不同实体的组
   • 每个组 = 一个实体的不同语言表达

禁止的合并理由（这些不是合并的有效理由）：
✗ 共享关系："都满足与H的关系R" → 不足以构成共指
✗ 语义相似："X和Y相似/相关" → 相似性 ≠ 同一性
✗ 相同类别："都是类型T" → 类别成员资格 ≠ 实体同一性
✗ 共现："X和Y一起出现" → 上下文接近 ≠ 共指
✗ 功能关系："X导致/影响/包含Y" → 关系 ≠ 同一性
✗ 共享属性："X和Y有属性P" → 属性共享 ≠ 实体同一性
✗ 同一集合的一部分："X, Y ∈ 集合_S" → 集合成员资格 ≠ 元素同一性

多值关系：
许多关系将一个头实体映射到多个不同的尾实体。每个尾实体是一个独立的实例。
模式：如果H与关系R有{T1, T2, ..., Tn}，每个Ti通常是一个不同的实体。
只有当Ti和Tj是同一实体的不同名称时才合并它们，而不仅仅因为它们都满足R。

决策程序：
对于每对尾实体(Ti, Tj)：
  1. 问："Ti和Tj是否指代同一实体？"（不是"它们相关吗？"）
  2. 应用替换测试：交换它们会改变信息吗？
  3. 如果不确定 → 保持分离（保守原则）

保守原则：
错误分割（保持共指实体分离）< 错误合并（合并不同实体）
有疑问时，保留区别。

输出要求：
1. 每个输入索引必须恰好出现在一个组中
2. 每个组代表一个实体及其各种表达形式
3. 按照以下优先级规则选择代表性表达：
   a) 优先选择完整形式而非缩写（例如：'磁共振成像' > 'MRI'）
   b) 优先选择全称而非简称（例如：'自旋回波序列' > 'SE序列'）
   c) 优先选择描述性术语而非首字母缩写/代码（例如：'高血压' > 'HTN'）
   d) 优先选择信息量最大、最具自解释性的表达
   e) 避免选择缩写/首字母缩写，除非不存在完整形式
4. 提供基于指称同一性的清晰理由

使用以下严格的JSON格式响应：
{
  "groups": [
    {"members": [1, 3], "representative": 3, "rationale": "为什么这些表达是共指的（相同指称对象）。"}
  ]
}
```

---

## 2. 属性去重Prompt（DEFAULT_ATTRIBUTE_DEDUP_PROMPT_ZH）

```
你是一个知识图谱管理助手，负责执行属性值去重任务。
所有列出的三元组共享相同的头实体和关系。

头实体：{head}
关系：{relation}

头实体上下文：
{head_context}

候选属性值：
{candidates}

任务：识别哪些属性值是等价的（表达完全相同的属性-值对）。

基本原则：
等价要求值同一性：两个表达必须指代完全相同的属性-值组合。
- 合并：'值_A' 和 '值_A_不同表达' → 相同值（不同表达）
- 不合并：'值_X' 和 '值_Y' → 不同值（不同的属性-值对）

关键区别 - 关系满足 vs 值同一性：
⚠️  如果多个值都满足与头实体H的关系R，这并不意味着它们是等价的。
每个值可以是恰好满足同一关系的不同属性/测量。
形式逻辑：(H,R,V1) ∧ (H,R,V2) ↛ V1=V2（共同满足不意味着值等价）

合并条件 - 必须全部满足：
1. 相同属性：两个值描述相同的属性/维度/特性。
   • 属性_A 和 属性_B → 保持分离（不同属性）
   • 属性_A 和 属性_A → 进入条件2

2. 相同值：两者表达该属性的相同测量/状态/数量。
   • 值_1 和 值_2 → 保持分离（不同值）
   • 值_X 和 值_X → 进入条件3

3. 语言变体：差异仅在表达上，而非含义上。
   可接受的变体：
   • 单位转换：'10厘米' = '100毫米'（相同长度，不同单位）
   • 语言：'水' = 'H₂O' = 'water'（相同物质，不同语言/记号）
   • 记法：'五十' = '50' = '5×10¹'（相同数字，不同表示）

禁止的合并理由（这些不是合并的有效理由）：
✗ 共享实体："都是H的属性" → 不足以构成等价
✗ 共享关系："都满足与H的关系R" → 不足以构成等价
✗ 相同领域："都来自领域D" → 领域成员资格 ≠ 值同一性
✗ 相关属性："属性_A影响属性_B" → 关系 ≠ 等价
✗ 相似量级："值_1 ≈ 值_2" → 相似性 ≠ 同一性
✗ 共现："V1和V2一起出现" → 相关性 ≠ 等价
✗ 模式的一部分："V1, V2 ∈ {属性集合}" → 集合成员资格 ≠ 元素同一性

多值属性：
许多实体对于同一关系类型拥有多个不同的属性值。
模式：如果H与关系R有{A1, A2, ..., An}，每个Ai通常是一个不同的属性值。
只有当Ai和Aj以不同方式表达相同的属性-值时才合并它们。

决策程序：
对于每对值(Vi, Vj)：
  1. 问："Vi和Vj表达相同的属性吗？" → 如果否，保持分离
  2. 问："Vi和Vj表达相同的值/测量吗？" → 如果否，保持分离
  3. 问："差异仅在语言/记号上吗？" → 如果否，保持分离
  4. 如果不确定 → 保持分离（保守原则）

保守原则：
错误分割（保持等价值分离）< 错误合并（合并不同值）
有疑问时，保留区别。

输出要求：
1. 每个输入索引必须恰好出现在一个组中
2. 每个组代表一个属性-值对及其各种表达形式
3. 按照以下优先级规则选择代表性表达：
   a) 优先选择完整形式而非缩写（例如：'磁共振成像' > 'MRI'）
   b) 优先选择全称而非简称（例如：'自旋回波序列' > 'SE序列'）
   c) 优先选择描述性术语而非首字母缩写/代码（例如：'高血压' > 'HTN'）
   d) 优先选择最完整、最具信息量的表达
   e) 避免选择缩写/首字母缩写，除非不存在完整形式
4. 提供基于值同一性的清晰理由

使用以下严格的JSON格式响应：
{
  "groups": [
    {"members": [1, 3], "representative": 3, "rationale": "为什么这些是等价的（相同属性-值）。"}
  ]
}
```

---

## 关键改进点

### 代表性表达选择规则（新增）

修改前（模糊）：
```
3. Choose the most informative expression as representative
```

修改后（明确优先级）：
```
3. 按照以下优先级规则选择代表性表达：
   a) 优先选择完整形式而非缩写（例如：'磁共振成像' > 'MRI'）
   b) 优先选择全称而非简称（例如：'自旋回波序列' > 'SE序列'）
   c) 优先选择描述性术语而非首字母缩写/代码（例如：'高血压' > 'HTN'）
   d) 优先选择信息量最大、最具自解释性的表达
   e) 避免选择缩写/首字母缩写，除非不存在完整形式
```

### 实际应用示例

**你提供的例子：**
- 输入候选：
  - "SE序列" (entity_26)
  - "自旋回波序列" (entity_45)

**按照新规则的正确输出：**
```json
{
  "groups": [
    {
      "members": [0, 2],
      "representative": 2,
      "rationale": "SE序列与自旋回波序列指代完全相同的MRI脉冲序列，前者为后者的常用缩写。根据优先选择全称而非简称的原则，选择'自旋回波序列'作为代表性表达，因为它具有更好的自解释性和信息完整性。"
    }
  ]
}
```

注意：现在representative应该指向index=2（自旋回波序列），而不是index=0（SE序列）。
